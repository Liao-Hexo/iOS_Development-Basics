原理：存入到自动释放池中的对象，在自动释放池被销毁的时候，会自动调用存储在该自动释放池中的所有对象的release方法

可以解决的问题：将创建的对象，存入到自动释放池之中，就不再需要手动的release这个对象了，因为池子销毁的时候，就会自动的调用池中所有的对象的release

如何创建自动释放池：
@autoreleasepool{

}
这对大括弧代表这个自动释放池的范围

如何将对象存储到自动释放池之中：在自动释放池之中调用对象的autorelease方法，就会将这个对象存入到当前自动释放池之中

这个autorelease方法返回的是对象本身，所以我们可以这么写：
@autoreleasepool{
      Person *p1=[[[Person alloc] init] autorelease];
}
这个时候，当这个自动释放池执行完毕之后，就会立即为这个自动释放池中的对象发送一条release消息
![](https://tva1.sinaimg.cn/large/0081Kckwly1gly47ex751j309h03ajry.jpg)


八大注意：
1）只有在自动释放池中调用了对象的autorelease方法，这个对象才会被存储到这个自动释放池之中，如果只是将对象的创建代码写在自动释放池之中，而没有调用对象的autorelease方法，是不会将这个对象存储到这个自动释放池之中的
2）对象的创建可以在自动释放池的外面，在自动释放池之中调用对象的autorelease方法，就可以将这个对象存储到这个自动释放池之中
3）如果对象的autorelease方法的调用放在自动释放池的外面，是无法将其存储到这个自动释放池之中的，autorelease的调用只有放在自动释放池之中，才可以将其存储到自动释放池
4）当自动释放池结束的时候，仅仅是对存储在自动释放池中的对象发送一条release消息，而不是销毁对象
5）如果在自动释放池中调用同一个对象的autorelease方法多次，就会将对象存储多次到自动释放池之中，在自动释放池结束的时候，会为对象发送多条release消息，那么这个时候就会出现僵尸对象错误
6）如果在自动释放池中调用了存储到自动释放池中的对象的release方法，在自动释放池结束的时候，还会再调用对象的release方法，这个时候就有可能会造成野指针操作（也可以调用存储在自动释放池中的对象的retain方法）
7）将对象存储到自动释放池并不会使对象的引用计数器+1，所以其好处就是：创建对象将对象存储在自动释放池，就不需要再写一个release了
8）自动释放池可以嵌套，调用对象的autorelease方法，会将对象加入到当前自动释放池之中，只有在当前自动释放池结束的时候才会向对象发送release消息