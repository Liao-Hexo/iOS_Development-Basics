### 内存中的五大区域：

1. 栈：存储局部变量
2. 堆：程序员手动申请的字节空间
3. BSS段：存储未被初始化的全局变量、静态变量
4. 数据段（常量区）：存储已被初始化的全局变量、静态变量、常量数据
5. 代码段：存储代码，存储程序的代码

### 类加载：

在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个过程叫做类加载；只有类在第一次被访问的时候才会做类加载，一旦类被加载到代码段以后，直到程序结束的时候才会被释放。
1）在创建对象的时候，肯定是需要访问类的
2）声明一个类的指针变量也会访问类的

- - - -

### 对象在内存中究竟是如何存储的：

假设这个写在函数之中：Person *p1=[Person new];
1. Person *p1：会在栈内存中申请一块空间，在栈内存中声明一个Person类型的指针变量p1。p1是一个指针变量，只能存储地址
2. [Person new]：真正在内存中创建对象的其实是这句代码

New做的事情：
1. 在堆内存中申请一块合适大小的空间
2. 在这个空间中根据类的模版创建对象，类模版中定义了什么属性，就把这些属性依次的声明在对象之中，对象中还有另外一个属性，叫做isa，是一个指针，指向对象所属的类在代码段中的地址
3. 初始化对象的属性：
如果属性的类型是基本数据类型，那么就赋值为0；
如果是C语言的指针类型就赋值为NULL；
如果是OC的类指针类型，就赋值为nil

NULL(nil)只能作为指针变量的值，如果一个指针变量的值是NULL(nil)代表这个指针不指向内存中的任何一块空间，NULL(nil)其实是一个宏，就是0

建议：C指针用NULL，int *p1=NULL;
     OC的类指针用nil，Person *p1=nil;

如果一个类指针的值为nil，代表这个指针不指向任何对象：Person *p1=nil;
这个时候，如果通过p1指针去访问p1指针指向的对象的属性，会运行报错；
如果通过p1指针去调用对象的方法，运行不会报错但是方法不会执行，没有反应

4. 返回对象的地址：

![](https://tva1.sinaimg.cn/large/0081Kckwly1gly3egsgpuj30tu0ee0ud.jpg)

- - - -

### 注意：

1. 对象中只有属性，而没有方法，自己类的属性+一个isa指针指向代码段中的类
2. 如何访问对象的属性：指针名->属性名；
根据指针，找到指针所指的对象，再找到对象中的属性来访问
3. 如何调用方法：[指针名 方法名];
先根据指针名找到对象，对象发现要调用方法，再根据对象的isa指针找到类，然后调用类里的方法
4. 为什么不把方法存储在对象中：因为每一个对象的方法的代码实现都是一模一样的，没有必要为每一个对象都保存一个方法，这样的话就太浪费空间了

- - - -

### 同类型的指针变量之间是可以相互赋值的：

Person *p1=[Person new];
Person *p2=p1;

这是完全没有问题的，p1和p2的类型都是Person指针类型的，代表将p1的值赋值给p2，而p1的值是对象的地址，所以就把对象的地址赋值给了p2，所以p1和p2指向了同一个对象
![](https://tva1.sinaimg.cn/large/0081Kckwly1gly3eptuz8j30t10gsdi1.jpg)

![](https://tva1.sinaimg.cn/large/0081Kckwly1gly3eyt68jj30eu0hiq50.jpg)

- - - -

### 目前为止，只要看见new，就说明新创建了一个对象：

![](https://tva1.sinaimg.cn/large/0081Kckwly1gly3f685doj30s40ic0vf.jpg)

![](https://tva1.sinaimg.cn/large/0081Kckwly1gly3fdfd6oj30fi0hnjtj.jpg)